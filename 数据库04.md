<h1 align="center">SQL-DQL</h1>

<img src="img/12.png">



### 代码写的 user是一个 表名 ，数据每一行代表一个员工，员工有name，id，idcard，date，sex等属性：



### DQL-基本查询



#### 注：

- 字段列表表示   字段1,字段2，字段3...  

- 字段代表属性名
-  [ “ ” ] 的方括号 代表可以加或者不用加 ； [ ]  不用加进代码段。





#### 查询多个字段

` select 字段1,字段2... from 表名;`

( 这里表示返回 指定字段 的内容 )

` select * from 表名;`

( * 这里表示返货全部字段的数据内容  ，尽量不要使用，影响开发效率。)



#### 设置别名

` select 字段1 [as 别名1],字段2[as 别名2 ]... from 表名;`

（ 这里的 as 可以不用加 ）



#### 去除重复记录

` select distinct 字段列表 from 表名 ;`

(查询的内容不重复)



#### 案例：

不重复查询 user的 所有数据表格：

`select distinct * from user;`





### DQL-条件查询



#### 语法：

 ` select 字段列表 from 表名 where 条件列表 ;`



<img src="img/13.png" width="900px">



#### 案例：

- 查询 表名为 user 的 id = “ 01” 的 所有员工：

` select * from user where id="01";`

- 查询 没有身份证号的 所有员工：

` select * from user where is NULL ;`           ( 有身份证号的就是 ` NOT is NULL`)

- 查询 age 在 15到20的所有员工：

` select * from user where between 15 and 20; `        ( 注意：15 和20 对调会报错)

- **重：查询名字占2个字大小的所有员工**：

` select * from user where name like '_ _';`      

（用两个 下划线 _ _ 代表 匹配俩个任意字符。 也可以 用ABC等字符代表匹配ABC等字符）



- **重：查询身份证号（18位）最后一个为 X 的所有员工：**

` select * from user where idcard like '%X';`      

  (% 实现模糊搜索 ， 不需要占位)或者：

`select * from user where idcard like '_________________X';`   ( 有17个 _  占位 再加一个X 代表搜索指定18位字符)

**注：会输出身份证号最后一位是X的员工的全部信息。**





### DQL-聚合函数

**介绍** ：将一列数据作为一个整体，进行纵向计算。

<img src="img/14.png">

<h5 align="center">count &nbsp&nbsp max &nbsp&nbsp min &nbsp&nbsp avg &nbsp&nbsp sum</h5>



#### 语法：

` select 聚合函数（字段列表）from 表名;`

**注：所有的null不参与计算。**



#### 案例：

- 统计所有员工数量 ：

` select count(*) from user;`         或者：  ` select count(id) from user;`



#### 注意：

只有 count 统计员工 数量 括号里面 才可以加 * ，比如count(* )，其他函数不能括号里面 ***不可以是***   *。

比如avg(*) 不知道代表啥含义。



- 统计所有 男性 ( sex) 员工年龄( age )之和：

`select sum ( age ) from user where sex='男';`

**假设员工年龄之和为135 则查询后会输出：**

<table><tr><th>sum(*)</th></tr><tr><td>135</td></tr></table>





### DQL-分组查询

#### 语法：

`select 字段列表 from 表名 [ where 条件 ] group by 分组字段名 [ having 分组后过滤条件 ]；`

**注：where和having的区别**

- 执行时机不同：where先判断过滤 再分组；having先分组后过滤。
- 判断条件不同：where不能对聚合函数进行判断；having可以。



#### 案例：



- #### 1.按性别进行分组，统计男员工女员工数量：

` select sex,count( * ) from user group by sex;`

 **注：用 ，隔开。**

**解析： ** 假设有 7个男员工和 8 个女员工：

如果只是 	`select count( * ) from user group by sex;`    	则会输出：

<table><tr><th>count(*)</th></tr><tr><td>7</td></tr><tr><td>8</td></tr></table>

而加个，使俩个一起参与则会输出：

<table><tr><th>sex</th><th>count(*)</th></tr><tr><td>男</td><td>7</td></tr><tr><td>女</td><td>8</td></tr></table>



- #### 2.查询年龄小于18岁的员工，根据性别分组，并过滤身份证号最后一位不是 XY 。

` select sex, count(*) from user where age<18 group by sex having idcard like '%X' or idcard like '%Y'; `











### 案例：创建user并执行一些操作：

<img src="img/15.png">

忘记添加年龄的属性了，添加一波：



<img src="img/16.png">

插入年龄的数据出错，插到后面去了，删除并修改：

<img src="img/17.png">



进行最后的操作：查询年龄小于18岁的员工，根据性别分组，并过滤身份证号最后一位不是 XY 。

( 好像额。。。识别不了中文的男女 我就改了一下)

<img src="img/18.png">

可以看出俩个的区别吧！





### 可以知道 select 后面紧跟的 字段集 是分行的 依据 ！





### DQL-排序查询

将指定数据进行排序（**注意：多字段排序查询，是在第一次排序查询的基础上进行排序查询**）

#### 语法：

` select 字段列表 from 表名 order by 字段1 排序方式1，字段2 排序方式2;`

**排序方式**

- asc 升序  (默认值 ：如果没有加则直接以升序进行排序)   （ 1,2,3,4,5,6 ）
- desc 降序   (6,5,4,3,2,1)



**案例：**

根据年龄对公司进行升序排序，**年龄相同，再按id进行降序排序**：

` select * from user order by age asc,id desc;`



因为前面设置了 age和 id都设置为varchar(10)，将id改为int型，并且排序id：

**注意：修改数据类型操作会自动把数据的字符型改为整数型**

本来：这里的id是字符型：改为自动变成整数型

<img src="img/19.png">



且看俩个的区别：



<img src="img/20.png">







### SQL-分类查询

#### 语法：

` select 字段列表 from 表名 limit 起始索引 , 查询记录数 ;` 

limit 放在语句最后面，在order by之后

**注意**

- 起始索引从0开始，起始索引=(查询页码-1)*每页显示记录数。
- 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。
- 如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10。

<img src="img/21.png">





案例：查询第二页员工数据，每页展示2条记录---------------------->(查询页码-1)*每页显示记录数

` select * from user limit 2,2 ;`

#### 其他案例：

查询年龄是 17,19岁的 男员工：

` select * from user where sex="男" and age=in(17,19)`;           in( . . . ) 后面加值表示满足这些值的数



   

### SQL-执行顺序

<img src="img/22.png">



**验证：**

` select e.name ,e.age from user e where e.age>17 order by age asc;`

===

` select name ,age from user where age>17 order by age asc;`



e 是表 user的别名 ，如果先进行，则后面可以使用 e . age 属性。







### 可以在字段后面加  [as 别名]   设置别名

